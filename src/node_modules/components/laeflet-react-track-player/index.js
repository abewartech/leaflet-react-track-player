import React from "react";
import PropTypes from "prop-types";
import moment from "moment";
import L from "leaflet";
import Control from "react-leaflet-control";
import Dots from "./dots";
import { MapLayer, withLeaflet } from "react-leaflet";
import { findLastIndex } from "lodash";
import "./multyPolyline";
import "./snake";
import "./index.css";

class LeafletReactTrackPlayer extends MapLayer {
  constructor(props) {
    super(props);
    this.state = {
      activePosition: 0,
      track: [],
      active: true,
      activeTimeOrIndex: props.progressFormat === "time" ? props.track[0].t : 0,
      durationTrack:
        props.progressFormat === "time"
          ? moment(
              props.track[this.props.track.length - 1].t,
              props.timeFormat
            ) - moment(props.track[0].t, props.timeFormat)
          : 0,
      speed: props.speedArray[0],
      maxDistance: props.track.reduce((result, item, index) => {
        var point = L.latLng(item);
        if (props.track[index + 1]) {
          result = result + point.distanceTo(props.track[index + 1]);
        }
        return result;
      }, 0),
      openSpeedControl: false
    };
  }

  flyTrack = (point) => {
    if (point) {
      if (this.props.progressFormat === "distance") {
        this.leafletElement.finishMarker.setLatLng(point.point);
        // console.log(point.distance, this.state.maxDistance)
        this.setState({
          activePosition: (point.distance / this.state.maxDistance) * 100
        });
        this.props.callbackFly(point.point);
      } else {
        this.leafletElement.finishMarker.setLatLng(point);
        this.props.callbackFly(point);
      }
    }
  }

  nextPoint = (point, index) => {
    // callback: add new point to step of animation
    if (this.props.progressFormat === "default") {
      this.setState({
        activePosition: (index / this.props.track.length) * 100
      });
    } else if (this.props.progressFormat === "time") {
      const thisDistance =
        moment(point.t, this.props.timeFormat) -
        moment(this.props.track[0].t, this.props.timeFormat);
      this.setState({
        activeTimeStamp: point.t,
        activePosition: thisDistance / (this.state.durationTrack / 100)
      });
    }
    this.leafletElement.finishMarker.setIcon(this.createIcon(point.course));
  }

  finishTrack = (lastPosition) => {
    // callback: end of animation or last point after changing position
    if (lastPosition) {
      this.setState({
        active: false,
        activeTimeStamp:
          this.props.progressFormat === "default" ||
          this.props.progressFormat === "distance"
            ? this.props.track.length - 1
            : this.props.track[this.props.track.length - 1].t,
        activePosition: 100
      });
      this.leafletElement.finishMarker.setLatLng(
        this.props.track[this.props.track.length - 1]
      );
      this.props.callbackFinish();
    }
    this.setState({ active: false });
  }

  componentDidMount() {
    this.leafletElement.snakePolyline.snakeIn({
      fly: (point) => this.flyTrack(point),
      nextPoint: (point, index) => this.nextPoint(point, index),
      finish: lastPosition => this.finishTrack(lastPosition),
      change: point => {
        // callback: changing position
        if (point) this.leafletElement.finishMarker.setLatLng(point);
      }
    });
  }

  changeActivePosition = e => {
    const coordinates = e.target.getBoundingClientRect();
    const activeX = e.pageX;
    const activePosition =
      (activeX - coordinates.left) / (this.line.clientWidth / 100);
      switch (this.props.progressFormat) {
        case "default": {
          const indexPoint = Number(
            (activePosition * (this.props.track.length / 100)).toFixed()
          );
          this.leafletElement.snakePolyline.changePosition(indexPoint);
        }
        case "time": {
          const activePositionTime = moment(
            this.props.track[0].t,
            this.props.timeFormat
          ).add((this.state.durationTrack / 100) * activePosition, "millisecond");
          this.leafletElement.snakePolyline.changePosition(
            activePositionTime.format(this.props.timeFormat),
            true
          );
        }
      }
    if (this.props.progressFormat === "default") {
      const indexPoint = Number(
        (activePosition * (this.props.track.length / 100)).toFixed()
      );
      this.leafletElement.snakePolyline.changePosition(indexPoint);
    } else if (this.props.progressFormat === "time") {
      
    } else if (this.props.progressFormat === "distance") {
      this.leafletElement.snakePolyline.changePosition(
        (this.state.maxDistance / 100) * activePosition
      );
    }
  };

  tooglePlay = () => {
    this.setState(
      {
        active: !this.state.active
      },
      () => {
        if (this.state.active) {
          this.leafletElement.snakePolyline.snakePlay();
        } else this.leafletElement.snakePolyline.snakeStop();
      }
    );
  };

  nextStep = () => {
    const indexActiveButton = findLastIndex(
      this.props.track,
      item => item.t === this.state.activeTimeStamp
    );
    if (
      indexActiveButton !== -1 &&
      indexActiveButton !== this.props.track.length - 1
    ) {
      this.leafletElement.snakePolyline.changePosition(
        this.props.track[indexActiveButton + 1].t
      );
      this.props.callbackNext(this.props.track[indexActiveButton + 1]);
    }
  };

  prevStep = () => {
    const indexActiveButton = findLastIndex(
      this.props.track,
      item => item.t === this.state.activeTimeStamp
    );
    if (indexActiveButton >= 1) {
      this.leafletElement.snakePolyline.changePosition(
        this.props.track[indexActiveButton - 1].t
      );
      this.props.callbackPrev(this.props.track[indexActiveButton + 1]);
    }
  };

  createLeafletElement() {
    // icon
    this.createIcon = rotate =>
      L.divIcon({
        html: `<div class="custom-marker-player${
          !this.props.customMarker ? " default" : ""
        }" style="background: url('${
          this.props.customMarker
            ? this.props.markerIcon
            : "https://unpkg.com/leaflet@1.3.4/dist/images/marker-icon-2x.png"
        }') no-repeat center; height: 100%; transform: rotate(${
          this.props.customMarker && this.props.changeCourseCustomMarker
            ? rotate
            : 0
        }deg)${this.props.styleMarker}"></div>`,
        iconSize: [35, 35]
      });
    const finishMarker = L.marker(this.props.track[0], {
      icon: this.createIcon(this.props.track[0].course)
    });
    this.props.leaflet.map.addLayer(finishMarker);

    // poluline
    const snakePolyline = L.multiOptionsPolyline(this.props.track, {
      multiOptions: {
        optionIdxFn: this.props.optionMultyIdxFn
          ? this.props.optionMultyIdxFn
          : function() {},
        options: this.props.optionsMulty ? this.props.optionsMulty : []
      },
      timeFormat: this.props.timeFormat,
      progressFormat: this.props.progressFormat
    });
    this.props.leaflet.map.addLayer(snakePolyline);
    return {
      snakePolyline,
      finishMarker
    };
  }

  changeSpeed = xSpeed =>
    this.setState(
      {
        speed: xSpeed
      },
      () => {
        this.leafletElement.snakePolyline.changeSpeed(xSpeed);
        this.props.callbackSpeed(xSpeed);
      }
    );

  render() {
    return (
      <Control position="bottomleft">
        <div className="leaflet-control leaflet-react-track-player">
          <div className="tp-buttons">
            <button
              className="tp_button prev"
              onClick={() => this.prevStep()}
            />
            <button
              className={`tp_button ${this.state.active ? "pause" : "play"}`}
              onClick={() => this.tooglePlay()}
            />
            <button
              className="tp_button next"
              onClick={() => this.nextStep()}
            />
            <button
              className="tp_button speed"
              onClick={() =>
                this.setState({
                  openSpeedControl: !this.state.openSpeedControl
                })
              }
            />
            {this.state.openSpeedControl ? (
              <div className="tp-speed">
                {this.props.speedArray.map(item => (
                  <button
                    key={item}
                    className={`tp-speed-item${
                      this.state.speed === item ? " active" : ""
                    }`}
                    onClick={() => this.changeSpeed(item)}
                  >
                    {item}
                  </button>
                ))}
              </div>
            ) : null}
          </div>
          <div className="tp_track-line">
            <div
              className="tp_track-line_line"
              ref={line => {
                this.line = line;
              }}
              onClick={e => this.changeActivePosition(e)}
            >
              <div
                key={this.state.activePosition}
                style={{ width: `${this.state.activePosition}%` }}
                className="tp_track-line_active"
              />
            </div>
            <div
              className="tp_track-points"
              ref={e => {
                this.pointsLine = e;
              }}
            >
              <Dots
                key={"markers"}
                track={this.props.track}
                type={this.props.progressFormat}
                timeFormat={this.props.timeFormat}
                maxDistance={this.state.maxDistance}
                durationTrack={this.state.durationTrack}
              />
            </div>
          </div>
        </div>
      </Control>
    );
  }
}

LeafletReactTrackPlayer.defaultProps = {
  track: [],
  optionMultyIdxFn: function() {},
  optionsMulty: [],
  customMarker: false,
  iconCustomMarker: "",
  changeCourseCustomMarker: false,
  timeFormat: "YYMMDDHHmmss000",
  styleMarker: "",
  speedArray: [1, 10, 50, 100, 1000],
  progressFormat: "default",
  callbackFinish: function() {},
  callbackPrev: function() {},
  callbackNext: function() {},
  callbackSpeed: function() {},
  callbackFly: function() {}
};

LeafletReactTrackPlayer.propTypes = {
  track: PropTypes.arrayOf(PropTypes.object),
  optionMultyIdxFn: PropTypes.func,
  optionIdxFn: PropTypes.arrayOf(PropTypes.object),
  customMarker: PropTypes.bool,
  iconCustomMarker: PropTypes.string,
  changeCourseCustomMarker: PropTypes.bool,
  timeFormat: PropTypes.string,
  styleMarker: PropTypes.string,
  speedArray: PropTypes.arrayOf(PropTypes.number),
  progressFormat: PropTypes.string,
  callbackFinish: PropTypes.func,
  callbackNext: PropTypes.func,
  callbackPrev: PropTypes.func,
  callbackSpeed: PropTypes.func,
  callbackFly: PropTypes.func
};

export default withLeaflet(LeafletReactTrackPlayer);
