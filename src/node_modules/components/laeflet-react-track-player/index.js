import React from "react";
import PropTypes from "prop-types";
import moment from "moment";
import L from "leaflet";
import Control from "react-leaflet-control";
import { MapLayer, withLeaflet } from "react-leaflet";
import { findLastIndex } from "lodash";
import "./multyPolyline";
import "./snake";
import "./index.css";

class LeafletReactTrackPlayer extends MapLayer {
  constructor(props) {
    super(props);
    this.state = {
      track: [],
      active: true,
      activeTimeOrIndex: props.progressFormat === "time" ? props.track[0].t : 0,
      durationTrack:
        props.progressFormat === "time"
          ? moment(
              props.track[this.props.track.length - 1].t,
              props.timeFormat
            ) - moment(props.track[0].t, props.timeFormat)
          : 0,
      speed: props.speedArray[0],
      maxDistance: props.track.reduce((result, item, index) => {
        var point = L.latLng(item);
        if (props.track[index + 1]) {
          result = result + point.distanceTo(props.track[index + 1]);
        }
        return result;
      }, 0),
      openSpeedControl: false,
      init: false,
    };
  }

  componentDidMount() {
    this.leafletElement.snakePolyline.snakeIn({
      fly: point => {
        // callback: changing animation
        if (point) {
          if (this.props.progressFormat === "distance") {
            this.leafletElement.finishMarker.setLatLng(point.point);
            if (this.progressLine) {
              this.progressLine.style.width = `${(point.distance / this.state.maxDistance) * 100}%`
            }
            this.props.callbackFly(point.point);
          } else {
            this.leafletElement.finishMarker.setLatLng(point);
            this.props.callbackFly(point);
          }
        }
      },
      nextPoint: (point, index) => {
        // callback: add new point to step of animation
        if (this.props.progressFormat === "default") {
          this.setState({
            activePosition: (index / this.props.track.length) * 100
          });
        } else if (this.props.progressFormat === "time") {
          const thisDistance =
            moment(point.t, this.props.timeFormat) -
            moment(this.props.track[0].t, this.props.timeFormat);
          this.setState({activeTimeStamp: point.t});
          if (this.progressLine) {
            this.progressLine.style.width = `${thisDistance / (this.state.durationTrack / 100)}%`
          }
        }
        this.leafletElement.finishMarker.setIcon(this.createIcon(point.course));
      },
      finish: lastPosition => {
        // callback: end of animation or last point after changing position
        if (lastPosition) {
          this.setState({
            active: false,
            activeTimeStamp:
              this.props.progressFormat === "default" ||
              this.props.progressFormat === "distance"
                ? this.props.track.length - 1
                : this.props.track[this.props.track.length - 1].t,
          });
          if (this.progressLine) {
            this.progressLine.style.width = `100%`
          }
          this.leafletElement.finishMarker.setLatLng(
            this.props.track[this.props.track.length - 1]
          );
          this.props.callbackFinish();
        }
        this.setState({ active: false });
      },
      change: point => {
        // callback: changing position
        if (point) this.leafletElement.finishMarker.setLatLng(point);
      }
    });
    this.setState({init: true})
  }

  changeActivePosition = e => {
    const coordinates = e.target.getBoundingClientRect();
    const activeX = e.pageX;
    const activePosition =
      (activeX - coordinates.left) / (this.line.clientWidth / 100);
    if (
      this.props.progressFormat === "default" ||
      this.props.progressFormat === "distance"
    ) {
      const indexPoint = Number(
        (activePosition * (this.props.track.length / 100)).toFixed()
      );
      this.leafletElement.snakePolyline.changePosition(indexPoint);
    } else {
      const activePositionTime = moment(
        this.props.track[0].t,
        this.props.timeFormat
      ).add((this.state.durationTrack / 100) * activePosition, "millisecond");
      this.leafletElement.snakePolyline.changePosition(
        activePositionTime.format(this.props.timeFormat),
        true
      );
    }
  };

  tooglePlay = () => {
    this.setState(
      {
        active: !this.state.active
      },
      () => {
        if (this.state.active) {
          this.leafletElement.snakePolyline.snakePlay();
        } else this.leafletElement.snakePolyline.snakeStop();
      }
    );
  };

  nextStep = () => {
    const indexActiveButton = findLastIndex(
      this.props.track,
      item => item.t === this.state.activeTimeStamp
    );
    if (
      indexActiveButton !== -1 &&
      indexActiveButton !== this.props.track.length - 1
    ) {
      this.leafletElement.snakePolyline.changePosition(
        this.props.track[indexActiveButton + 1].t
      );
      this.props.callbackNext(this.props.track[indexActiveButton + 1]);
    }
  };

  prevStep = () => {
    const indexActiveButton = findLastIndex(
      this.props.track,
      item => item.t === this.state.activeTimeStamp
    );
    if (indexActiveButton >= 1) {
      this.leafletElement.snakePolyline.changePosition(
        this.props.track[indexActiveButton - 1].t
      );
      this.props.callbackPrev(this.props.track[indexActiveButton + 1]);
    }
  };

  createLeafletElement() {
    // icon
    this.createIcon = rotate =>
      L.divIcon({
        html: `<div class="custom-marker-player${
          !this.props.customMarker ? " default" : ""
        }" style="background: url('${
          this.props.customMarker
            ? this.props.markerIcon
            : "https://unpkg.com/leaflet@1.3.4/dist/images/marker-icon-2x.png"
        }') no-repeat center; height: 100%; transform: rotate(${
          this.props.customMarker && this.props.changeCourseCustomMarker
            ? rotate
            : 0
        }deg)${this.props.styleMarker}"></div>`,
        iconSize: [35, 35]
      });
    const finishMarker = L.marker(this.props.track[0], {
      icon: this.createIcon(this.props.track[0].course)
    });
    this.props.leaflet.map.addLayer(finishMarker);

    // poluline
    const snakePolyline = L.multiOptionsPolyline(this.props.track, {
      multiOptions: {
        optionIdxFn: this.props.optionMultyIdxFn
          ? this.props.optionMultyIdxFn
          : function() {},
        options: this.props.optionsMulty ? this.props.optionsMulty : []
      },
      timeFormat: this.props.timeFormat,
      progressFormat: this.props.progressFormat
    });
    this.props.leaflet.map.addLayer(snakePolyline);
    return {
      snakePolyline,
      finishMarker
    };
  }

  changeSpeed = xSpeed =>
    this.setState(
      {
        speed: xSpeed
      },
      () => {
        this.leafletElement.snakePolyline.changeSpeed(xSpeed);
        this.props.callbackSpeed(xSpeed);
      }
    );

  render() {
    var prevProcent = 0;
    return (
      <Control position="bottomleft">
        <div className="leaflet-control leaflet-react-track-player">
          <div className="tp-buttons">
            <button
              className="tp_button prev"
              onClick={() => this.prevStep()}
            />
            <button
              className={`tp_button ${this.state.active ? "pause" : "play"}`}
              onClick={() => this.tooglePlay()}
            />
            <button
              className="tp_button next"
              onClick={() => this.nextStep()}
            />
            <button
              className="tp_button speed"
              onClick={() =>
                this.setState({
                  openSpeedControl: !this.state.openSpeedControl
                })
              }
            />
            {this.state.openSpeedControl ? (
              <div className="tp-speed">
                {this.props.speedArray.map(item => (
                  <button
                    key={item}
                    className={`tp-speed-item${
                      this.state.speed === item ? " active" : ""
                    }`}
                    onClick={() => this.changeSpeed(item)}
                  >
                    {item}
                  </button>
                ))}
              </div>
            ) : null}
          </div>
          <div className="tp_track-line">
            <div
              className="tp_track-line_line"
              ref={line => {
                this.line = line;
              }}
              onClick={e => this.changeActivePosition(e)}
            >
              <div
                ref={progressLine => {
                  this.progressLine = progressLine
                }}
                className="tp_track-line_active"
              />
            </div>
            <div
              className="tp_track-points"
              ref={e => {
                this.pointsLine = e;
              }}
            >
              {this.props.track.map((item, index) => {
                
                let procent = 0;
                if (this.props.progressFormat === "default") {
                  procent = index / (this.props.track.length / 100);
                } else if (this.props.progressFormat === "time") {
                  const itemDuration =
                  moment(item.t, this.props.timeFormat) -
                  moment(this.props.track[0].t, this.props.timeFormat);
                  procent = itemDuration / (this.state.durationTrack / 100);
                } else if (this.props.progressFormat === "distance") {
                  let point = L.latLng(item);
                  if (this.props.track[index + 1]) {
                    var thisDistance = point.distanceTo(this.props.track[index + 1]);
                    prevProcent = prevProcent + thisDistance;
                    procent = (prevProcent / this.state.maxDistance) * 100
                  }
                }
                return (
                  <div
                    key={index}
                    className="tp_track-points_item"
                    style={{ left: `${procent}%` }}
                  />
                );
              })}
            </div>
          </div>
        </div>
      </Control>
    );
  }
}

LeafletReactTrackPlayer.defaultProps = {
  track: [],
  optionMultyIdxFn: function() {},
  optionsMulty: [],
  customMarker: false,
  iconCustomMarker: "",
  changeCourseCustomMarker: false,
  timeFormat: "YYMMDDHHmmss000",
  styleMarker: "",
  speedArray: [1, 10, 50, 100, 1000],
  progressFormat: "default",
  callbackFinish: function() {},
  callbackPrev: function() {},
  callbackNext: function() {},
  callbackSpeed: function() {},
  callbackFly: function() {}
};

LeafletReactTrackPlayer.propType = {
  track: PropTypes.arrayOf(PropTypes.object),
  optionMultyIdxFn: PropTypes.func,
  optionIdxFn: PropTypes.arrayOf(PropTypes.object),
  customMarker: PropTypes.bool,
  iconCustomMarker: PropTypes.string,
  changeCourseCustomMarker: PropTypes.bool,
  timeFormat: PropTypes.string,
  styleMarker: PropTypes.string,
  speedArray: PropTypes.arrayOf(PropTypes.number),
  progressFormat: PropTypes.string,
  callbackFinish: PropTypes.func,
  callbackNext: PropTypes.func,
  callbackPrev: PropTypes.func,
  callbackSpeed: PropTypes.func,
  callbackFly: PropTypes.func
};

export default withLeaflet(LeafletReactTrackPlayer);
