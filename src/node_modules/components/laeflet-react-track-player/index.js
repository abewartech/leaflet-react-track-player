import React from "react"
import PropTypes from "prop-types";
import moment from "moment";
import L from 'leaflet';
import Control from "react-leaflet-control";
import { MapLayer, withLeaflet } from "react-leaflet";
import { findLastIndex } from "lodash";
import "./multyPolyline";
import "./snake";
import "./index.css"

class LeafletReactTrackPlayer extends MapLayer {
    constructor(props) {
        super(props)
        this.state = {
            activePosition: 0,
            track: [],
            active: true,
            activeTimeStamp: props.track[0].t,
            durationTrack: moment(props.track[this.props.track.length - 1].t, props.timeFormat) - moment(props.track[0].t, props.timeFormat),
            speed: props.speedArray[0],
            openSpeedControl: false
        }
    }

    componentDidMount() {
        this.leafletElement.snakePolyline.snakeIn({
            fly: (point) => {
                // callback: changing animation
                if (point) {
                    this.leafletElement.finishMarker.setLatLng(point);
                    this.props.callbackFly(point);
                }
            },
            nextPoint: (point) => {
                // callback: add new point to step of animation
                const thisDistance = moment(point.t, this.props.timeFormat) - moment(this.props.track[0].t, this.props.timeFormat);
                this.setState({ activeTimeStamp: point.t, activePosition: thisDistance / (this.state.durationTrack / 100) });
                this.leafletElement.finishMarker.setIcon(this.createIcon(point.course));
            },
            finish: (lastPosition) => {
                // callback: end of animation or last point after changing position
                if (lastPosition) {
                    this.setState({ active: false, activeTimeStamp: this.props.track[this.props.track.length - 1].t, activePosition: 100 })
                    this.leafletElement.finishMarker.setLatLng(this.props.track[this.props.track.length - 1]);
                    this.props.callbackFinish()
                }
                this.setState({ active: false });
            },
            change: (point) => {
                // callback: changing position
                if (point) this.leafletElement.finishMarker.setLatLng(point);
            }
        })
    }

    changeActivePosition = (e) => {
        const coordinates = e.target.getBoundingClientRect();
        const activeX = e.pageX;
        const activePosition = (activeX - coordinates.left) / (this.line.clientWidth / 100)
        if (this.props.playerAndTime) {
            const activePositionTime = moment(this.props.track[0].t, this.props.timeFormat).add((this.state.durationTrack / 100) * activePosition, "millisecond");
            this.leafletElement.snakePolyline.changePosition(activePositionTime.format(this.props.timeFormat), true);
        } else {
            const indexPoint = Number((activePosition * (this.props.track.length / 100)).toFixed());
            this.leafletElement.snakePolyline.changePosition(indexPoint);
        }
    }

    tooglePlay = () => {
        this.setState({
            active: !this.state.active,
        }, () => {
            if (this.state.active) {
                this.leafletElement.snakePolyline.snakePlay();
            } else this.leafletElement.snakePolyline.snakeStop();
        })
    }

    nextStep = () => {
        const indexActiveButton = findLastIndex(this.props.track, (item) => item.t === this.state.activeTimeStamp);
        if (indexActiveButton !== -1 && indexActiveButton !== this.props.track.length - 1) {
            this.leafletElement.snakePolyline.changePosition(this.props.track[indexActiveButton + 1].t);
            this.props.callbackNext(this.props.track[indexActiveButton + 1])
        }
    };

    prevStep = () => {
        const indexActiveButton = findLastIndex(this.props.track, (item) => item.t === this.state.activeTimeStamp);
        if (indexActiveButton >= 1) {
            this.leafletElement.snakePolyline.changePosition(this.props.track[indexActiveButton - 1].t)
            this.props.callbackPrev(this.props.track[indexActiveButton + 1])
        }
    }

    createLeafletElement() {
        // icon
        this.createIcon = (rotate) => L.divIcon({
            html: `<div class="custom-marker-player${!this.props.customMarker ? " default" : ""}" style="background: url('${this.props.customMarker ? this.props.markerIcon : "https://unpkg.com/leaflet@1.3.4/dist/images/marker-icon-2x.png"}') no-repeat center; height: 100%; transform: rotate(${this.props.customMarker && this.props.changeCourseCustomMarker ? rotate : 0}deg)${this.props.styleMarker}"></div>`,
            iconSize: [35, 35],
        })
        const finishMarker = L.marker(this.props.track[0], { icon: this.createIcon(this.props.track[0].course) })
        this.props.leaflet.map.addLayer(finishMarker);

        // poluline
        const snakePolyline = L.multiOptionsPolyline(this.props.track, {
            multiOptions: {
                optionIdxFn: this.props.optionMultyIdxFn ? this.props.optionMultyIdxFn : function () { return },
                options: this.props.optionsMulty ? this.props.optionsMulty : [],
            },
            timeFormat: this.props.timeFormat,
            playerAndTime: this.props.playerAndTime
        });
        this.props.leaflet.map.addLayer(snakePolyline);
        return {
            snakePolyline, finishMarker
        }
    }

    changeSpeed = (xSpeed) => this.setState({
        speed: xSpeed,
    }, () => {
        this.leafletElement.snakePolyline.changeSpeed(xSpeed);
        this.props.callbackSpeed(xSpeed);
    })

    render() {
        return (
            <Control position="bottomleft">
                <div className="leaflet-control leaflet-react-track-player">
                    <div className="tp-buttons">
                        <button className="tp_button prev" onClick={() => this.prevStep()} />
                        <button className={`tp_button ${this.state.active ? "pause" : "play"}`} onClick={() => this.tooglePlay()} />
                        <button className="tp_button next" onClick={() => this.nextStep()} />
                        <button className="tp_button speed" onClick={() => this.setState({ openSpeedControl: !this.state.openSpeedControl })} />
                        {this.state.openSpeedControl ? (
                            <div className="tp-speed">
                                {this.props.speedArray.map((item) => <button
                                    key={item}
                                    className={`tp-speed-item${this.state.speed === item ? " active" : ""}`}
                                    onClick={() => this.changeSpeed(item)}
                                >{item}</button>)}
                            </div>
                        ) : null}
                    </div>
                    <div className="tp_track-line">
                        <div className="tp_track-line_line" ref={(line) => { this.line = line }} onClick={(e) => this.changeActivePosition(e)}>
                            <div className="tp_track-line_active" style={{ width: `${this.state.activePosition}%` }} />
                        </div>
                        <div className="tp_track-points" ref={(e) => { this.pointsLine = e }}>
                            {this.props.track.map((item, index) => {
                                const itemDuration = moment(item.t, this.props.timeFormat) - moment(this.props.track[0].t, this.props.timeFormat);
                                const procent = this.props.playerAndTime ? 
                                    itemDuration / (this.state.durationTrack / 100) :
                                    index / (this.props.track.length / 100);
                                return <div key={index} className="tp_track-points_item" style={{ left: `${procent}%` }} />
                            })}
                        </div>
                    </div>
                </div>
            </Control>
        );
    }
}

LeafletReactTrackPlayer.defaultProps = {
    track: [],
    optionMultyIdxFn: function () {},
    optionsMulty: [],
    customMarker: false,
    iconCustomMarker: "",
    changeCourseCustomMarker: false,
    timeFormat: "YYMMDDHHmmss000",
    styleMarker: "",
    speedArray: [1, 10, 50, 100, 1000],
    playerAndTime: false,
    callbackFinish: function () {},
    callbackPrev: function () {},
    callbackNext: function () {},
    callbackSpeed: function () {},
    callbackFly: function () {}
}

LeafletReactTrackPlayer.propType = {
    track: PropTypes.arrayOf(PropTypes.object),
    optionMultyIdxFn: PropTypes.func,
    optionIdxFn: PropTypes.arrayOf(PropTypes.object),
    cusomMarker: PropTypes.bool,
    iconCustomMarker: PropTypes.string,
    changeCourseCustomMarker: PropTypes.bool,
    timeFormat: PropTypes.string,
    styleMarker: PropTypes.string,
    speedArray: PropTypes.arrayOf(PropTypes.number),
    playerAndTime: PropTypes.bool,
    callbackFinish: PropTypes.func,
    callbackNext: PropTypes.func,
    callbackPrev: PropTypes.func,
    callbackSpeed: PropTypes.func,
    callbackFly: PropTypes.func,
}

export default withLeaflet(LeafletReactTrackPlayer);