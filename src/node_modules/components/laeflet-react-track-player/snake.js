import L from "leaflet";
import moment from "moment"

L.Polyline.include({
	_snakingTimestamp: 0,
	_snakingVertices: 0,
	_snakingDistance: 0,
	_snaking: false,
	_stopTime: 0,
	_xSpeed: 1,
	_play: true,
	_now: 0,
	_latLngAnimation: null,

	// It initialization polyline with animation
	snakeIn: function (e) {
		if (e && !this._latLngAnimation) this._latLngAnimation = e;
		if (this._snaking) { return; }
		if (!this._snakeLatLngs) this._snakeLatLngs = this._latlngs;
		this._snaking = true;
		this._play = true;
		this._snakingTime = 0;
		this._path.style.display = "block";
		this._snakingVertices = this._snakingDistance = 0;
		this._latlngs = [this._snakeLatLngs[0], this._snakeLatLngs[0]];
		this._nextPoint();
		this._snake();
		this.fire('snakestart');
		return this;
	},

	// It initialization polyline with set LatLng and without animation
	initDefaultPosition: function (params) {
		this._latLngAnimation = params.animate;
		this._snaking = params.last;
		this._play = false;
		this._snakingTime = 0;
		this._snakingVertices = params.points.length !== 1 ? params.points.length - 2 : 0;
		const lastPoints = params.points[params.points.length - 2] ? [params.points[params.points.length - 2], params.points[params.points.length - 1]] : null;
		this._snakingDistance = lastPoints ? lastPoints.reduce((result, item, index) => {
			if (index > 0) {
				const currPoint = this._map.latLngToContainerPoint(lastPoints[index - 1]);
				const nextPoint = this._map.latLngToContainerPoint(item);
				result = result + currPoint.distanceTo(nextPoint);
			}
			return result;
		}, 0) : 0;
		if (this._snakingDistance) {
			this._path.style.display = "block";
		}
		if (params.last) {
			for (var i in this._eventParents) {
				this._eventParents[i]._takeActivePoint(params.points[params.points.length - 1], params.index);
			}
		}
		if (!this._snakeLatLngs) this._snakeLatLngs = this._latlngs;
		if (this._snakeLatLngs.length === params.points.length) {
			this.setLatLngs(this._snakeLatLngs);
			this._snaking = false;
		} else {
			if (params.points.length !== 1) {
				this.setLatLngs(params.points);
			} else {
				this.fire('snakestart');
				this.setLatLngs([this._snakeLatLngs[0], this._snakeLatLngs[0]])
			}
		}
	},

	// delete LatLngs, but not remove polyline. 
	removePosition: function () {
		this._play = false;
		this._snakingTime = 0;
		this._snakingDistance = 0;
		this._snaking = false;
		this._path.style.display = "none";
		this.setLatLngs([this._snakeLatLngs[0], this._snakeLatLngs[0]]);
	},

	// stopping animation
	snakeStop: function () {
		this._play = false;
		this._stopTime = this._now;
	},

	// starting animation
	snakePlay: function () {
		this._snaking = true;
		this._path.style.display = "block";
		this._play = true;
		this._now = this._snakingTime;
		this.startTime();
		this._snake();
	},

	changeSpeed: function (xSpeed) {
		this._xSpeed = xSpeed;
	},

	// counter of time for calculation process animation
	startTime: function () {
		var startTime = Date.now();
		var self = this;
		const flyTime = function () {
			var _now = Date.now() - startTime + self._stopTime;
			self._now = _now;
			if (self._play) setTimeout(flyTime, 10);
		}
		setTimeout(flyTime, 10);
	},

	// new iteration of animation
	_snake: function () {
		if (!this.maxDistance) {
			this.maxDistance = this._snakeLatLngs[0].distanceTo(this._snakeLatLngs[1]);
		}
		if (this._play) {
			var time = this._timeDistance ? this._timeDistance / this._xSpeed : 1;
			var diff = this._now - this._snakingTime;
			var forward = this.maxDistance ? diff * (this.maxDistance / time) / 1000 :  diff * (1 / time) / 1000;
			this._snakingTime = this._now;
			this._latlngs.pop();
			this._forward = forward;
			return this._snakeForward(forward);
		}
	},

	_snakeForward: function (forward) {
		if (!this._now) this.startTime();
		if (this._play && this._map) {
			var currPoint = this._map.latLngToContainerPoint(
				this._snakeLatLngs[this._snakingVertices]);
			var nextPoint = this._map.latLngToContainerPoint(
				this._snakeLatLngs[this._snakingVertices + 1]);
			this.maxDistance = this._snakeLatLngs[this._snakingVertices].distanceTo(this._snakeLatLngs[this._snakingVertices + 1]);

			// next point from _snakeLatLngs is added into polylile
			if (this._snakingDistance + forward > this.maxDistance) {
				this._snakingVertices++;
				this._latlngs.push(this._snakeLatLngs[this._snakingVertices]);

				// finish animation
				if (this._snakingVertices >= this._snakeLatLngs.length - 1) {
					this._snakingVertices = 0;
					this._latlngs = this._snakeLatLngs
					return this._snakeEnd();
				}
				this._nextPoint();
				this._snakingDistance -= this.maxDistance;
				return this._snakeForward(forward);
			}
			this._snakingDistance += forward;
			var percent = this.maxDistance ? this._snakingDistance / this.maxDistance : 0;
			var headPoint = nextPoint.multiplyBy(percent).add(
				currPoint.multiplyBy(1 - percent)
			);
			var headLatLng = this._map.containerPointToLatLng(headPoint);
			this._latlngs.push(headLatLng);
			if (this._latLngAnimation) {
				this._latLngAnimation(headLatLng);
			}
			this.setLatLngs(this._latlngs);
			this.fire('snake');
			L.Util.requestAnimFrame(this._snake, this);
		}
	},

	_nextPoint: function () {
		for (var i in this._eventParents) {
			var countLayer = this._eventParents[i]._snakingLayersDone - 1;
			var point = this._eventParents[i]._detailData[countLayer][this._snakingVertices];
			if (this._eventParents[i]._options.playerAndTime) {
				
				this._eventParents[i]._takeActivePoint(point);
				const nextTimeStamp = moment(this._eventParents[i]._detailData[countLayer][this._snakingVertices + 1].t, this._eventParents[i]._options.timeFormat);
				const thisTimeStamp = moment(this._eventParents[i]._detailData[countLayer][this._snakingVertices].t, this._eventParents[i]._options.timeFormat);
				this._timeDistance = (nextTimeStamp - thisTimeStamp) / 1000;
			} else {
				var count = this._eventParents[i]._detailData.reduce((result, item, index) => {
					if(index < countLayer) {
						result = result + item.length - 1;
					}
					return result;
				},0);
				count = count + this._snakingVertices;
				this._eventParents[i]._takeActivePoint(point, count);
				this._timeDistance = 10;
			}
		}
	},

	_snakeEnd: function () {
		this._play = false;
		this._snaking = false;
		this.setLatLngs(this._snakeLatLngs);
		for (var i in this._eventParents) {
			this._eventParents[i]._snakeNext();
		}
	}
});

// group polilines
L.LayerGroup.include({
	_snakingLayers: [],
	_snakingLayersDone: 0,
	_latLngAnimation: null,
	_takeActivePoint: null,
	_end: null,
	_callbackChangePosition: null,

	snakeStop: function () {
		this._snakingLayers.map((item) => {
			if (item._map) item.snakeStop();
		})
	},

	snakePlay: function () {
		this._snakingLayers.map((item) => {
			if (item._map && item._snaking) item.snakePlay();
		});
	},

	// change position. This function stopping work of animation and initiate polylines with default state. Need timestamp
	changePosition: function (value) {
		const filterData = this._options.playerAndTime ? 
		this._detailData.reduce((result, item, index) => {
			var filterData = item.filter((itm) => Number(itm.t) <= Number(value));
			if (filterData.length >= 1) {
				result.last = index;
			}
			result.data.push(filterData);
			return result;
		}, { data: [], last: 0 }) : 
		this._detailData.reduce((result, item, index) => {
			if (result.count > item.length) {
				result.data.push(item);
				result.count = result.count - item.length;
			} else {
				if (result.count > 0 && result.count <= item.length) {
					const d = item.filter((itm, ind) => ind <= result.count);
					result.data.push(d)
					result.last = index;
					result.count = result.count - d.length;
				} else {
					result.data.push([]);
				}
			}
			return result;
		}, { data: [], last: 0, count: value });
		filterData.data.map((item, index) => {
			if (item.length && !this._snakingLayers[index]._map) this.addLayer(this._snakingLayers[index]);
			if (item.length) {
				this._snakingLayers[index].initDefaultPosition({
					animate: this._latLngAnimation,
					last: index === filterData.last,
					points: item,
					index: value
				});
			}
			if (!item.length && this._snakingLayers[index]._map) this._snakingLayers[index].removePosition();
		});
		this._snakingLayersDone = filterData.last + 1;
		var last = filterData.data[filterData.last];
		this._callbackChangePosition(last[last.length - 1]);
		this._end(false);
	},

	changeSpeed: function (xSpeed) {
		this._snakingLayers.map((item) => {
			item.changeSpeed(xSpeed);
		})
	},

	snakeIn: function (events) {
		if (!this._callbackChangePosition && events.change) this._callbackChangePosition = events.change;
		if (!this._latLngAnimation && events.fly) {
			this._latLngAnimation = function (point) {
				events.fly(point)
			}
		}
		if (!this._takeActivePoint && events.nextPoint) this._takeActivePoint = events.nextPoint;
		if (!this._end && events.finish) this._end = events.finish;
		this._snaking = true;
		this._snakingLayers = [];
		this._snakingLayersDone = 0;
		var keys = Object.keys(this._layers);
		for (var i in keys) {
			var key = keys[i];
			this._snakingLayers.push(this._layers[key]);
		}
		this.clearLayers();
		this._detailDistance = this._detailData.map((polyline) => {
			const distance = polyline.reduce((result, point, index) => {
				if (index > 0) {
					const currPoint = this._map.latLngToContainerPoint(polyline[index - 1]);
					const nextPoint = this._map.latLngToContainerPoint(point);
					result = result + currPoint.distanceTo(nextPoint);
				}
				return result;
			}, 0);
			return distance;
		});
		this._maxDistance = this._detailDistance.reduce((result, item) => {
			result = result + item;
			return result;
		}, 0);
		return this._snakeNext();
	},

	_snakeNext: function () {
		if (this._snakingLayersDone >= this._snakingLayers.length) {
			this._end(true);
			this._snaking = false;
			return;
		}
		var currentLayer = this._snakingLayers[this._snakingLayersDone];
		this._snakingLayersDone++;
		if (!this.hasLayer(currentLayer)) {
			this.addLayer(currentLayer);
			currentLayer.snakeIn(this._latLngAnimation);
		} else currentLayer.snakePlay();
	}
});