import L from "leaflet";

L.Polyline.include({
	_snakingTimestamp: 0,
	_snakingVertices: 0,
	_snakingDistance: 0,
	_snaking: false,
	_stopTime: 0,
	_play: true,
	_now: 0,
	latLngAnimation: null,

	snakeIn: function (e) {
		if (e && !this.latLngAnimation) this.latLngAnimation = e;
		if (this._snaking) { return; }
		if (!this._snakeLatLngs) this._snakeLatLngs = this._latlngs;
		this._snaking = true;
		this._play = true;
		this._snakingTime = 0;
		this._path.style.display = "block";
		this._snakingVertices = this._snakingDistance = 0;
		this._latlngs = [this._snakeLatLngs[0], this._snakeLatLngs[0]];
		this._update();
		this._snake();
		this.fire('snakestart');
		return this;
	},

	initDefaultPosition: function (params) {
		this.latLngAnimation = params.animate;
		this._snaking = params.last ? true : false;
		this._play = false;
		this._snakingTime = 0;
		this._snakingVertices = params.points.length !== 1 ? params.points.length - 2 : 0;
		const lastPoints = params.points[params.points.length - 2] ? [params.points[params.points.length - 2], params.points[params.points.length - 1]] : null;
		this._snakingDistance = lastPoints ? lastPoints.reduce((result, item, index) => {
			if (index > 0) {
				const currPoint = this._map.latLngToContainerPoint(lastPoints[index - 1]);
				const nextPoint = this._map.latLngToContainerPoint(item);
				result = result + currPoint.distanceTo(nextPoint);
			}
			return result;
		}, 0) : 0;
		if (!this._snakeLatLngs) this._snakeLatLngs = this._latlngs;
		if (this._snakeLatLngs.length === params.points.length) {
			this._play = false;
			this.setLatLngs(this._snakeLatLngs);
			this._snaking = false;
		} else {
			if (params.points.length !== 1) {
				this.setLatLngs(params.points);
			} else {
				this.fire('snakestart');
				this.setLatLngs([this._snakeLatLngs[0], this._snakeLatLngs[0]])
			}
		}
	},

	removePosition: function () {
		this._play = false;
		this._snakingTime = 0;
		this._snakingDistance = 0;
		this._snaking = false;
		this._path.style.display = "none";
		this.setLatLngs([this._snakeLatLngs[0], this._snakeLatLngs[0]]);
	},

	snakeStop: function () {
		this._play = false;
		this._stopTime = this._now;
	},

	snakePlay: function () {
		this._snaking = true;
		this._path.style.display = "block";
		this._play = true;
		this._now = this._snakingTime;
		this.startTime();
		this._snake();
	},

	startTime: function () {
		var startTime = Date.now();
		var self = this;
		const flyTime = function () {
			var _now = Date.now() - startTime + self._stopTime;
			self._now = _now;
			if (self._play) setTimeout(flyTime, 10);
		}
		setTimeout(flyTime, 10);
	},

	_snake: function () {
		if (this._play) {
			var diff = this._now - this._snakingTime;	// In milliseconds
			var forward = diff * this.options.snakingSpeed / 1000;	// In pixels
			this._snakingTime = this._now;
			this._latlngs.pop();
			this._forward = forward;
			return this._snakeForward(forward);
		}
	},

	_snakeForward: function (forward) {
		if (!this._now) this.startTime();
		if (this._play && this._map) {
			var currPoint = this._map.latLngToContainerPoint(
				this._snakeLatLngs[this._snakingVertices]);
			var nextPoint = this._map.latLngToContainerPoint(
				this._snakeLatLngs[this._snakingVertices + 1]);
			var distance = currPoint.distanceTo(nextPoint);
			if (this._snakingDistance + forward > distance) {
				this._snakingVertices++;
				this._latlngs.push(this._snakeLatLngs[this._snakingVertices]);
				if (this._snakingVertices >= this._snakeLatLngs.length - 1) {
					this._snakingVertices = 0;
					this._latlngs = this._snakeLatLngs
					return this._snakeEnd();
				}
				this.changeCourse();
				this._snakingDistance -= distance;
				return this._snakeForward(forward);
			}
			this._snakingDistance += forward;
			var percent = this._snakingDistance / distance;
			var headPoint = nextPoint.multiplyBy(percent).add(
				currPoint.multiplyBy(1 - percent)
			);
			var headLatLng = this._map.containerPointToLatLng(headPoint);
			this._latlngs.push(headLatLng);
			if (this.latLngAnimation) {
				this.latLngAnimation(headLatLng, { n: this._snakingVertices, distance: this._snakingDistance + forward });
			}
			this.setLatLngs(this._latlngs);
			this.fire('snake');
			L.Util.requestAnimFrame(this._snake, this);
		}
	},

	changeCourse: function () {
		for (var i in this._eventParents) {
			var countLayer = this._eventParents[i]._snakingLayersDone - 1;
			var point = this._eventParents[i]._detailData[countLayer][this._snakingVertices];
			this._eventParents[i].next(point);
		}
	},

	_snakeEnd: function () {
		this._play = false;
		this._snaking = false;
		this.changeCourse();
		this.setLatLngs(this._snakeLatLngs);
		for (var i in this._eventParents) {
			this._eventParents[i]._snakeNext();
		}
	}
});

L.Polyline.mergeOptions({
	snakingSpeed: 200,	// In pixels/sec
});

L.LayerGroup.include({
	_snakingLayers: [],
	_snakingLayersDone: 0,
	latLngAnimation: null,
	next: null,
	end: null,

	snakeStop: function () {
		this._snakingLayers.map((item) => {
			if (item._map) item.snakeStop();
		})
	},

	snakePlay: function () {
		this._snakingLayers.map((item) => {
			if (item._map && item._snaking) item.snakePlay();
		});
	},

	changePosition: function (time) {
		const filterData = this._detailData.reduce((result, item, index) => {
			var filterData = item.filter((itm) => Number(itm.t) <= Number(time));
			if (filterData.length >= 1) {
				result.last = index;
			}
			result.data.push(filterData);
			return result;
		}, { data: [], last: 0 });
		filterData.data.map((item, index) => {
			if (item.length && !this._snakingLayers[index]._map) this.addLayer(this._snakingLayers[index]);
			if (item.length) {
				this._snakingLayers[index].initDefaultPosition({
					animate: this.latLngAnimation,
					last: index === filterData.last,
					points: item
				});
			}
			if (!item.length && this._snakingLayers[index]._map) this._snakingLayers[index].removePosition();
		});
		this._snakingLayersDone = filterData.last + 1;
		var prevRange = 0;
		var activeRange = 0;
		if (this._snakingLayersDone > 1) {
			prevRange = this._detailDistance.reduce((result, range, index) => {
				if (index < this._snakingLayersDone - 1) result = result + range;
				return result;
			}, 0);
		}
		var last = filterData.data[filterData.last];
		activeRange = last.reduce((result, item, index) => {
			if (index > 0) {
				const currPoint = this._map.latLngToContainerPoint(last[index - 1]);
				const nextPoint = this._map.latLngToContainerPoint(item);
				result = result + currPoint.distanceTo(nextPoint);
			}
			return result;
		}, 0);
		this.callbackChangePosition(last[last.length - 1], (activeRange + prevRange) / (this._maxDistance / 100));
		this.end();
	},

	procentProgress: function (e, point, progress) {
		if (progress) {
			var prevRangeColors = 0;
			var activePolylineRange = 0;
			if (this._snakingLayersDone > 1) {
				prevRangeColors = this._detailDistance.reduce((result, range, index) => {
					if (index < this._snakingLayersDone - 1) result = result + range;
					return result;
				}, 0);
			}
			if (progress.n > 0) {
				activePolylineRange = this._detailData[this._snakingLayersDone - 1].reduce((result, point, index) => {
					if (index > 0 && index < progress.n + 1) {
						const currPoint = this._map.latLngToContainerPoint(this._detailData[this._snakingLayersDone - 1][index - 1]);
						const nextPoint = this._map.latLngToContainerPoint(point);
						result = result + currPoint.distanceTo(nextPoint);
					}
					return result;
				}, 0);
			}
			var resultDistance = prevRangeColors + activePolylineRange + progress.distance;
			return e(point, resultDistance / (this._maxDistance / 100));
		}
	},

	snakeIn: function (e, n, end, change) {
		if (!this.callbackChangePosition && change) this.callbackChangePosition = change;
		if (!this.latLngAnimation && e) {
			var self = this
			this.latLngAnimation = function (point, progress) {
				self.procentProgress(e, point, progress);
			}
		}
		if (!this.next && n) this.next = n;
		if (!this.end && end) this.end = end;
		this._snaking = true;
		this._snakingLayers = [];
		this._snakingLayersDone = 0;
		var keys = Object.keys(this._layers);
		for (var i in keys) {
			var key = keys[i];
			this._snakingLayers.push(this._layers[key]);
		}
		this.clearLayers();
		this._detailDistance = this._detailData.map((polyline) => {
			const distance = polyline.reduce((result, point, index) => {
				if (index > 0) {
					const currPoint = this._map.latLngToContainerPoint(polyline[index - 1]);
					const nextPoint = this._map.latLngToContainerPoint(point);
					result = result + currPoint.distanceTo(nextPoint);
				}
				return result;
			}, 0);
			return distance;
		});
		this._maxDistance = this._detailDistance.reduce((result, item) => {
			result = result + item;
			return result;
		}, 0);
		return this._snakeNext();
	},

	_snakeNext: function () {
		if (this._snakingLayersDone >= this._snakingLayers.length) {
			this.end();
			this._snaking = false;
			return;
		}
		var currentLayer = this._snakingLayers[this._snakingLayersDone];
		this._snakingLayersDone++;
		if (!this.hasLayer(currentLayer)) {
			this.addLayer(currentLayer);
			currentLayer.snakeIn(this.latLngAnimation);
		} else currentLayer.snakePlay();

	}
});

L.LayerGroup.mergeOptions({
	snakingPause: 200,
});